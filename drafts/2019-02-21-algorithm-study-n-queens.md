---
layout: post
title: '알고리즘 공부 // N-Queens'
comments: true
author: seungyoon
date: 2019-02-21
tags: [JavaScript, Algorithm, Study, CodeStates]
---

# N-Queens 문제

N X N 체스판이 주어지고, 여기에 서로 공격하지 않도록 N개의 퀸을 놓을 수 있는 모든 경우의 수를 찾는 문제다.

## Queen의 공격방법

체스를 해본 사람이라면 상식이지만, 체스에서 퀸(Queen)은 가장 강력한 말이다.
왜냐하면 가로, 세로, 대각선 모두 공격이 가능하기 때문이다.
그러니까 가로 한 줄, 세로 한 줄을 공격할 수 있는 룩(Rook)과
대각선으로 공격할 수 있는 비숍(Bishop)이 합쳐진 능력을 갖는 '사기캐'다.

## 문제 파악

가로 4칸, 세로 4칸(4 X 4)의 체스판을 생각해보자.

<figure>
  <img src="/assets/figures/nqueens-4by4-chessboard.png" alt="stack"/>
  <figcaption>가로 4칸, 세로 4칸(4 X 4)의 체스판에 Queen이 4개 올라간 모습.
  체스판에 배치된 퀸이 모두 서로를 공격하지 못하는 위치에 배치되어 있다.
  이 배치는 4 X 4에서 가능한 배치 2개 중 하나다.</figcaption>
</figure>

이 문제는 위의 배치처럼 총 4개의 퀸을 서로 공격하지 못하게 배치할 수 있는 모든 경우를 찾는 문제다.

그럼 어떻게 문제를 해결할 수 있을까?

# 풀이 전략

## 결정 트리(Decision Tree)

맨 윗줄의 한 칸에 퀸을 하나 놓았다고 생각하면,
그 다음 말을 놓을 수 있는 곳은 지금 놓은 위치를 제외한 모든 경우다.
하지만, 퀸이 공격할 수 있는 위치는 제외해야한다.
이런 식으로 하나씩 결정을 할 때마다 다음 결정을 할 때 고려해야할 옵션을 트리구조로 표현한 것을 결정 트리(decision tree)라고 한다.

여기서는 다음에 말을 놓을 수 있는 위치를 결정하는 과정을 트리구조로 추상화해서 문제에 접근해보려고 한다.
트리구조로 추상화한다는 것은 다음과 같은 것을 말한다.

```
<상황 1>
Q - - -
- - - -
- - - -
- - - -
```

먼저 위와 같이 처음 Q을 놓는다.
그 다음에 놓을 수 있는 위치는 다음의 6개의 위치다.

```
<상황 2>
Q - - -
- - C C
- C - C
- C C -
```

이 중 하나에 Q을 놓게되면, 결정 트리에서 선택할 수 있는 옵션이 다음과 같이 변하게 된다.

```
<상황 3>
Q - - -
- - Q -
- - - -
- C - -
```

만약에 "상황 2"에서 "상황 3"의 선택을 하지 않고 다른 선택을 했다면, 선택할 수 있는 옵션은 다음과 같이 "상황 3"과는 다른 모습을 띌 것이다.

```
<상황 4>
Q - - -
- - - Q
- C - -
- - C -
```

이와 같이 매 결정, 즉 말을 놓을 때마다 결정 구조의 선택할 수 있는 옵션은 달라진다.
그래서 모든 경우를 찾아보려면, 이런 결정을 트리구조로 생각하고 탐색하는 것이 유리할 것이다.

## 탐색할 경우의 수 줄이기: 명백히 불가능한 옵션 제거

"상황 1"를 다시 한번 살펴보자.
체스의 규칙을 모른다면, 퀸을 하나 올려두고 다음 퀸을 올릴 수 있는 위치는 다음 상황에서 'C'로 표시한 15개다.

```
<상황 5>
Q C C C
C C C C
C C C C
C C C C
```

우리는 체스의 규칙을 공부해서 아는 상태이므로 무엇이 불가능한 옵션인지 어려움 없이 알 수 있다.
Q을 놓은 첫번째 열과 첫번째 행, 그리고 대각선이다.

이를 제거하면 "상황 2"와 같이 선택할 수 있는 옵션이 정해질 것이다.

```
<상황 2>
Q - - -
- - C C
- C - C
- C C -
```

이 문제를 푸는 알고리즘에서 탐색해야하는 경우의 수를 줄이려면 이런 정보를 활용해야한다.
그래서 명백히 불가능한 옵션은 미리 제거하고, 탐색하지 않도록 알고리즘을 만들어야한다.

## 백트랙(Back-track)

이렇게 결정트리에서 탐색해야할 경우의 수를 줄였다고 문제를 해결할 수 있을까?
"똑똑한(sapiens)" 인간인 우리가 문제를 푼다면, 이 정도만 있어도 문제가 해결 가능할 것이다.
하지만 따라가기만 하면 문제가 해결되게 디자인한 알고리즘에서는 이런 "똑똑한" 부분을 우리가 디자인해야한다.

먼저 결정트리를 탐색하는 방법에 대해 생각해보자.
트리 검색 방법 중에 BFS(Breadth First Search, 너비우선탐색), DFS(Depth First Search, 깊이우선탐색) 방법이 있다.
여기서는 스택(stack)구조를 사용한 DFS를 사용해 탐색하려고 한다.
이 스택 구조를 사용한 DFS는 결국, 콜스택을 이용하는 방법인 재귀를 사용하겠다는 것이다.
자, 그럼 재귀만 사용하면 문제가 해결될까?

결정트리에서 막다른 곳에 도달한 경우를 생각해보자.
이때 탐색을 중지하면 될까?
아니다. 왜냐하면 다른 옵션도 확인해야하기 때문이다.
그렇다면 절차적으로 다른 옵션을 확인하게 하려면 어떤 방법을 쓰는 것이 좋을까?

만약에 결정트리에서 탐색을 하다가 N개의 말을 놓지 않았는데 더 이상의 옵션이 없는 상황이 오면,
바로 이전 단계로 돌아가 그 다음 옵션을 확인해야할 것이다.
이럴 때 사용할 수 있는 방법이 "백트랙(Back-track)"이다.

트리를 들어가면서 우리는 그곳이 가능한 옵션이라는 표시를 남겼을 것이다.
그곳이 막다른 길인 것을 알았다면, 당연히 이 표시를 지워야한다.
성공적으로 원하는 결과를 찾았더라도, 이 표시를 지워야한다.
왜냐하면 이미 그곳에서 결과를 찾았으므로 표시를 지우지 않으면 중복되는 결과를 주는 것에 더해,
검색을 영원히 수행할 수도 있기 때문이다.

# 문제해결 알고리즘: 수도코드

위에서 말한 문제 해결 전략을 사용해 수도코드로 알고리즘을 써보자.

```
- 커서를 첫번째 줄로 옮긴다.
- 커서가 가능한 위치를 넘어가면,
  - 결과를 어딘가에 저장한다.
- [for문] 커서가 위치한 줄의 모든 칸에 대해 다음을 반복한다.
  - 말을 놓는다.
  - 충돌이 없는지 확인한다.
    - 충돌이 없다면,
      <반복>
        - 커서를 다음 줄로 옮긴다.
        - 커서가 가능한 위치를 넘어가면,
          - 결과를 어딘가에 저장한다.
          - [for문] 커서가 위치한 줄의 모든 칸에 대해 다음을 반복한다.
            - 말을 놓는다
            - ...
      - 말을 놓은 것을 취소한다.
    - 충돌이 있다면,
      - 말을 놓은 것을 취소한다.
```

충돌이 없을 때는 `<반복>`이라고 표시한 부분이 계속 같은 구조로 반복된다.
이 부분을 재귀로 만들면, 충돌이 생겼을 때 말을 놓은 것을 취소하고
이전 결정 트리 노드로 이동하게 된다.
이 부분은 백트랙을 알고리즘으로 구현한 것이다.

# 마치면서

처음에 이 문제를 접했을 때(재귀 공부할 때)는 전혀 감이 오지 않았다.
너무 복잡하게 생각하기도 했지만, 문제는 알고리즘을 먼저 생각하지 않고 바로 코딩을 하는 것으로 넘어간 것이었다.
이 방식으로는 알고리즘이 잘못된 것인지, 코딩을 잘못한 것인지 판단하기가 어렵고, 문제해결에 집중하기 어려웠다.

결국 답을 보긴 했지만, 이후에 알고리즘을 이해한 뒤에 코딩을 해보니 훨씬 쉬웠다.
코딩이 잘못된 것만 고치면 됐기 때문이었다.

앞으로 복잡한 문제를 만났을 때, 먼저 문제를 파악하고 전략을 세운 뒤, 수도코드를 짠 뒤에 코딩으로 넘어가는 연습을 더 많이 해야할 것 같다.

N-Queens 문제는 처음 상대했을 때는 매우 어려운 문제였지만, 공부하고 나면 재귀에 대한 이해를 깊게 할 수 있는 좋은 문제라고 생각한다.
특히 이 "백트랙"은 다른 곳에서도 써먹기 좋은 훌륭한 스킬(?)인 것 같다.
